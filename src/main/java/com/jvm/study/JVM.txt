
1、虚拟机的前世今生，深入理解JVM内存区域：{

	JVMs是C++、C、go语言写的，
	为什么要了解虚拟机：{
		写出更好、更优雅的Java程序
		排查问题，Java应用性能优化
		面试必问

		千万别说：重启重启，重启之前一定要保存堆栈日志。

	}

	虚拟机的发展：{
		HoptSpot VM(SUN)以前使用范围最广泛的java向虚拟机，
		JRockit VM(BEA) 号称世界上最快的虚拟机，
		HoptSpot VM(ORACLE) 目前世界上范围最广的java虚拟机。
			ORACLE把SUN和BEA都收购了合并成了现如今使用最广泛的JVM，
		jdk11推出了一个ZGC(回收内存要达到TB级别，每次回收要达到10毫秒，系统卡顿不超过10毫秒)：有色指针和加载屏障，
	}

	未来的Java技术：{
		模块化:OSGI（动态化、模块化），应用层面就是微服务，互联网的发展方向
		混合语言：多个语言都可以运行在JVM中，google的Kotlin 成为了 Android 的官方语言。Scala(Kafka)
		多核并行：CPU从高频次转变为多核心，多核时代。JDK1.7引入了Fork/Join，JDK1.8提出lambda表达式(函数式编程天生适合并行运行)
		丰富语法：JDK5提出自动装箱、泛型(并发编程讲到)、动态注解等语法。JDK7二进制原生支持。try-catch-finally 至try-with-resource
		64位：虽然同样的程序64位内存消耗比32位要多一点，但是支持内存大，所以虚拟机都会完全过渡到64位，32位的JVM有4G的堆大小限制。
		更强的垃圾回收器（现在主流CMS、G1）：JDK11 CZGC（暂停时间不超过10毫秒，且不会随着堆的增加而增加，TB级别的堆回收））：有色指针、加载屏障。JDK12支持并发类卸载，进一步缩短暂停时间  JDK13(计划于2019年9月)将最大堆大小从4TB增加到16TB

	}

	Java SE体系架构:{
		JavaSE，Java平台标准版，为Java EE和Java ME提供了基础。
		JDK：Java开发工具包，JDK是JRE的超集，包含JRE中的所有内容，以及开发程序所需的编译器和调试程序等工具。
		JRE：Java SE运行时环境 ，提供库、Java虚拟机和其他组件来运行用Java编程语言编写的程序。主要类库，包括：程序部署发布、用户界面工具类、继承库、其他基础库，语言和工具基础库
		JVM：java虚拟机，负责JavaSE平台的硬件和操作系统无关性、编译执行代码（字节码）和平台安全性

		jre体系中如果没有用到如JDBC，也是能跑通的；但是JVM是最基础的，是不能缺的的。
		java代码经过jdk的javac编译成.class文件(字节码)，再经过JVM把class文件翻译成操作系统的指令(就是常见的011000d)，
	}


	JVM运行时数据区(内存):就是指计算机上的内存，无论什么系统，都是内存，不是指磁盘----{
		这个是抽象概念，内部实现依赖寄存器、高速缓存、主内存（具体要分析JVM源码 C++语言实现，没必要看）
			计算机的运行=指令+数据，指令用于执行方法的，数据用于存放数据和对象的。
			虚拟机栈----执行java方法、本地方法栈---执行本地方法、程序计数器---程序执行的计数器
			Java中的数据：变量、常量、对象、数组相关。

		JVM在运行过程中会把它所管理的内存划分成若干不同的数据区域！
		线程私有:程序计数器、虚拟机栈、本地方法栈
		线程共享：堆、方法区

	}


	程序计数器/程序的计数器(虚拟机内存，唯一不会OOM)：{

		含义：指向当前线程正在执行的字节码指令的地址/行号。

		较小的内存空间，当前线程执行的字节码指令的行号指示器；
			各线程之间独立存储，互不影响（面试可能问到为什么需要）
			如果线程正在执行的是一个Java方法，则指明当前线程执行的代字节码行数
			如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）
			此内存区域是唯一一个不会出现OutOfMemoryError情况的区域。

		为什么需要程序计数器（面试）：{
			java是多线程的，记录线程执行地址方便线程切换；
			确保多线程情况下程序正常执行，
		}


	}

	用栈的结构完成代码的操作，
	虚拟机栈（JVM后续的执行子程序有详细的见解）：{

		栈/Stack：{
			栈是一种数据结构，
				入栈
				出栈
			特点：先进后出(FILO)，

		}
		为什么JVM使用栈？
			非常适合方法调方法，兼容这种特点。

		异常：
			线程请求的栈深度大于虚拟机所允许的深度：StackOverflowError
			JVM动态扩展时无法申请到足够的内存时：OutOfMemoryError


		虚拟机栈（大小设置  -Xss 1M：虚拟机栈如果不设置大小的话，默认1M ）
			存储当前线程运行方法所需的数据---->指令、返回地址

		每个线程私有的，线程在运行时，在执行每个方法的时候都会打包成一个栈帧，存储了局部变量表，操作数栈，动态链接，方法出口等信息，然后放入栈。
			每个时刻正在执行的当前方法就是虚拟机栈顶的栈桢。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。
			栈的大小缺省为1M，可用参数 CXss调整大小，例如-Xss256k
		在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中，
			因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。
		//重点
		栈帧--是对虚拟机栈的进一步划分:
			每个方法在执行的同时都会创建一个栈帧
			栈帧还可以划分：//栈帧不单单只有这四个东西，还有其他东西，只是这四个东西比较重要。
				局部变量表:{
					顾名思义就是局部变量的表，用于存放我们的局部变量的。
						首先它是一个32位的长度，主要存放我们的Java的八大基础数据类型，一般32位就可以存放下，如果是64位的就使用高低位占用两个也可以存放下，
						如果是局部的一些对象，比如我们的Object对象，我们只需要存放它的一个引用地址即可。（基本数据类型、对象引用、returnAddress类型）
				}

				操作数栈--->可以不连续，但是一定要是增序的:{
					存放我们方法执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的java数据类型，
						所以我们知道一个方法刚刚开始的时候，这个方法的操作数栈就是空的，操作数栈运行方法是会一直运行入栈/出栈的操作
				}

				动态连接:Java语言特性多态（需要类加载、运行时才能确定具体的方法，后续有详细的讲解）
				返回地址:正常返回（调用程序计数器中的地址作为返回）

				三步曲：
					恢复上层方法的局部变量表和操作数栈、
					把返回值（如果有的话）压入调用者栈帧的操作数栈中、
					调整PC计数器的值以指向方法调用指令后面的一条指令、
					异常的话（通过异常处理器表<非栈帧中的>来确定）




	}

	本地方法栈:{
		各虚拟机自由实现，本地方法栈native方法调用 JNI到了底层的C/C++(c/c++可以触发汇编语言，然后驱动硬件)

		本地方法栈保存的是native方法的信息，当一个JVM创建的线程调用native方法后，JVM不再为其在虚拟机栈中创建栈帧，JVM只是简单地动态链接并直接调用native方法

	}



	线程私有部分保存的是大多是指令，而公共区域保存的是数据，
	线程共享的区域：{
		类信息：
		类的完整有效名、返回值类型、修饰符(public，private...)、变量名、方法名、方法代码、这个类型直接父类的完整有效名(除非这个类型是interface或是 java.lang.Object，
			两种情况下都没有父类)、类的直接接口的一个有序列表

		方法区还一个叫法：永久代(<=1.7)、元空间(>=1.8)，只是一个版本的区分.
		方法区(永久代、元空间):{
			包括：类信息、常量、静态变量、即时编译期编译后的代码；
			用于存储已经被虚拟机加载的类信息，常量("zdy","123"等)，静态变量(static变量)等数据，可用以下参数调整：
				jdk1.7及以前：-XX:PermSize；-XX:MaxPermSize；
				jdk1.8以后：-XX:MetaspaceSize； -XX:MaxMetaspaceSize
				jdk1.8以后大小就只受本机总内存的限制
				如：-XX:MaxMetaspaceSize=3M

			常量：


			静态变量：

			即时编译期编译后的代码：


		}

		堆:{
			包括对象和成员变量，
			几乎所有对象都分配在这里，也是垃圾回收发生的主要区域，可用以下参数调整：
				-Xms：堆的最小值；
				-Xmx：堆的最大值；
				-Xmn：新生代的大小；
				-XX:NewSize；新生代最小值；
				-XX:MaxNewSize：新生代最大值；
				例如- Xmx256m
		}

		运行时常量池:{
			包括：符号引用和字面量.
			符号引用（一个概念）
				一个java类（假设为People类）被编译成一个class文件时，如果People类引用了Tool类，但是在编译时People类并不知道引用类的实际内存地址，因此只能使用符号引用来代替。
				而在类装载器装载People类时，此时可以通过虚拟机获取Tool类的实际内存地址，因此便可以既将符号org.simple.Tool替换为Tool类的实际内存地址，及直接引用地址。
				即在编译时用符号引用来代替引用类，在加载时再通过虚拟机获取该引用类的实际地址.
				以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
					符号引用与虚拟机实现的内存布局是无关的，引用的目标不一定已经加载到内存中。
			字面量
				文本字符串	String a = "abc",这个abc就是字面量
				八种基本类型int a = 1; 这个1就是字面量
				声明为final的常量

			常量池的变化
				运行时常量池
					Class 文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域。
					符号引用:
					字面量：String a =“享学课堂”
				JDK1.6
					运行时常量池在方法区中
				JDK1.7
					运行时常量池在堆中
				JDK1.8
					去永久代：使用元空间(空间大小只受制于机器的内存)替代永久代
					永久代参数	-XX:PermSize；-XX:MaxPermSize =100M   超过100M OOM（）
					元空间参数	-XX:MetaspaceSize； -XX:MaxMetaspaceSize
				why？
					永久代来存储类信息、常量、静态变量等数据不是个好主意, 很容易遇到内存溢出的问题。
					对永久代进行调优是很困难的,同时将元空间与堆的垃圾回收进行了隔离，避免永久代引发的Full GC和OOM等问题；



		}






	}

	直接内存---JVM直接管理不了的，内存中除运行时数据区剩余的部分:{
		使用Native函数库直接分配堆外内存(NIO)
		并不是JVM运行时数据区域的一部分，但是会被频繁使用(可以通过-XX:MaxDirectMemorySize来设置（默认与堆内存最大值一样,也会出现OOM异常)
		避免了在Java 堆和Native 堆中来回复制数据，能够提高效率
		测试用例JavaStack：设置JVM参数-Xmx100m，运行异常，因为如果没设置-XX:MaxDirectMemorySize，则默认与-Xmx参数值相同，分配128M直接内存超出限制范围.

		直接内存//重要：
			不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域；
			如果使用了NIO,这块区域会被频繁使用，在java堆内可以用directByteBuffer对象直接引用并操作；
			这块内存不受java堆大小限制，但受本机总内存的限制，可以通过MaxDirectMemorySize来设置（默认与堆内存最大值一样），所以也会出现OOM异常；
			避免了在Java 堆和Native 堆中来回复制数据，能够提高效率

	}

	站在线程角度来看:{
		线程私有的内存区：不需要过多考虑内存回收问题，随着线程产生和消亡，生命周期跟随现成的，
		线程共享的内存区：
	}

	深入辨析堆和栈:{
		功能
			以栈帧的方式存储方法调用的过程，并存储方法调用过程中基本数据类型的变量（int、short、long、byte、float、double、boolean、char等）以及对象的引用变量，
				其内存分配在栈上，变量出了作用域就会自动释放；
			而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中；
		线程独享还是共享
			栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。
			堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。
		空间大小
			栈的内存要远远小于堆内存,栈的深度是有限制的，可能发生StackOverFlowError问题。

	}




	反编译::{
		进入到某个文件目录：javap -v .class  >a.text
			-v:显示全一点，将.class文件反编译到a.text;
	}

	Java字节码指令收集大全：
		资料：https://www.cnblogs.com/longjee/p/8675771.html






}



2、情犊初开，JVM搞对象：{

	1.7/及以前:堆的区域以前可以称为永久代，对象分配和垃圾回收和堆一样，
	永久代和元空间的区别：内存分配和垃圾回收策略不同，

	堆：{
		堆：堆是内存分配和垃圾回收的重点区域，几乎所有的对象都是在堆中分配。
		检查加载---->内存分配---->内存初始化---->设置---->对象初始化(new 调用构造方法)
		实例数据：对象是哪个类的实例拥有，

	}


	虚拟机中的对象:{

		对象的分配:{

			虚拟机遇到一条new指令时：根据new的参数是否能在常量池中定位到一个类的符号引用,如果没有，说明还未定义该类，抛出ClassNotFoundException；

			1/检查加载
				先执行相应的类加载过程。如果没有，则进行类加载


			//内存是规整的使用指针碰撞，内存是零散的使用空闲列表。
			2/分配内存::根据方法区的信息确定为该类分配的内存空间大小
				2.1/指针碰撞	(java堆内存空间规整的情况下使用)
					接下来虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。
					如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，
						那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。
				2.2/空闲列表	(java堆空间不规整的情况下使用)
					如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，
						记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。
					选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
				2.3/并发安全
					除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，
						在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。
					2.3.1/CAS机制
						解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理――实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；
					2.3.2/分配缓冲
						另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块私有内存，
							也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），如果设置了虚拟机参数 -XX:+UseTLAB，在线程初始化时，
							同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，
							这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。
						TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间（Eden区，默认Eden的1%），减少同步开销。
						TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。
							当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB。
					//小结
					并发安全问题：
						分配内存什么时候使用CAS配置，什么时候使用本地线层分配缓冲

					本地线层分配缓冲(Thread Local Allocation Buffer,TLAB)：空间换时间，
						对象小的话会在永久代的Eden区分配内存，仅占1%，
						对象大的话，使用CAS比较和交换，确保原子性。

			3/内存空间初始化
				（注意不是构造方法）内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(如int值为0，boolean值为false等等)。
					这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
			4/设置
				接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。
				这些信息存放在对象的对象头之中。
			5/对象初始化
				在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。
					所以，一般来说，执行new指令之后会接着把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

		}

	}


	对象的内存布局:{

		在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。
			1/对象头包括两部分信息，
				第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。
				另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
			2/第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。
				由于HotSpot VM的自动内存管理系统要求对对象的大小必须是8字节的整数倍。
				对象正好是9字节的整数，所以当对象其他数据部分（对象实例数据）没有对齐时，就需要通过对齐填充来补全。

	}


	对象的访问定位:{

		建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针两种。
		句柄
			如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，
				而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
		直接指针
			如果使用直接指针访问， reference中存储的直接就是对象地址。
			这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，
				在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。
			使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，
				因此这类开销积少成多后也是一项非常可观的执行成本。
			对Sun HotSpot而言，它是使用直接指针访问方式进行对象访问的。

		//访问方式
		对象的访问方式：
			使用句柄：
			句柄池：句柄中包含了对象实例数据与类型数据各自的具体地址信息。
			对象实例数据在堆中，
			类型数据在方法区，属于哪个类，和哪个类进行关联的，

			直接指针：HotSpot使用都是直接指针


			实例数据变了直接指针需要修改reference,句柄需要修改句柄池

	}


	堆内存分配策略:{

		新生代：
			Eden区
			Survivor(from)区：设置Survivor是为了减少送到老年代的对象
			Survivor(to)区：设置两个Survivor区是为了解决碎片化的问题（复制回收算法）
			不设置的情况下：Eden:From：To==8:1:1

		java为什么流行：GC的强大，不用担心内存溢出，
		//FullGC 空间不够用了，触发FullGC ，是老年代触发的；FullGC 是老年代进行的，同时伴随着新生代的MinGC
		//当Eden区没有足够空间分配时，虚拟机将发起一次Minor GC。
		minGC频次较高，
		新生代：老年代===1:2
		Full GC会暂停：方便统计对象，但会影响性能，

		对象优先在Eden区分配:{
			虚拟机参数：
				-Xms20m 	//堆最小值，
				-Xmx20m 	//堆最大值:
				-Xmn10m 	//新生代大小参数，-Xmn20M表示新生代大小20M(初始和最大)，
				-XX:+PrintGCDetails //打印垃圾回收日志，程序退出时输出当前内存的分配情况
									//打印垃圾回收日志情况，同时打印堆使用比例，
				注意：新生代初始时就有大小
				大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间分配时，虚拟机将发起一次Minor GC。

		}

		大对象直接进入老年代:{
			-Xms20m
			-Xmx20m
			-Xmn10m
			-XX:+PrintGCDetails
			-XX:PretenureSizeThreshold=4m
			-XX:+UseSerialGC
			PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效。
			最典型的大对象是那种很长的字符串以及数组。这样做的目的：1.避免大量内存复制,2.避免提前进行垃圾回收，明明内存有空间进行分配。
		}

		长期存活对象进入老年区:

			如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1，
				对象在Survivor区中每熬过一次 Minor GC，年龄就增加1，当它的年龄增加到一定程度(默认为15)_时，就会被晋升到老年代中。

		对象年龄动态判定:
			如果在 Survivor空间中相同年龄所有对象大小的综合大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代

		空间分配担保:
			在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。
				如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，
				如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的，如果担保失败则会进行一次Full GC；如果小于，或者HandlePromotionFailure设置不允许冒险，
				那这时也要改为进行一次Full GC。

		空间分配担保：就是JVM把对象直接放入老年代，不用关心老年代是否能放得下，大多数情况下是可以放得下的，放不下在触发GC，
		空间分配担保作用：提高效率，不用每次都触发GC，

	}


	java的语法糖：JVM的泛型，泛型就是语法糖，本质Object,
	泛型有：K,V,T,E<K,V>.
		泛型本质就是形参，实际使用是实参，
		？可以表示所有，T泛型

	Java中的泛型----关注JVM的泛型实现:{

		泛型是什么:{
			泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？
			顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。

			泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，
				这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。
			引入一个类型变量T（其他大写字母都可以，不过常用的就是T，E，K，V等等），并且用<>括起来，并放在类名的后面。泛型类是允许有多个类型变量的。
		}

		泛型类
		泛型接口
		泛型方法

		为什么我们需要泛型？{

			实际开发中，经常有数值类型求和的需求，例如实现int类型的加法,有时候还需要实现long类型的求和,如果还需要double类型的求和，需要重新在重载一个输入是double类型的add方法。
			所以泛型的好处就是：
			?	适用于多种数据类型执行相同的代码
			?	泛型中的类型在使用时指定，不需要强制类型转换



		}


		虚拟机是如何实现泛型的？{
			Java语言中的泛型，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（Raw Type，也称为裸类型）了，
				并且在相应的地方插入了强制转型代码，因此，对于运行期的Java语言来说，ArrayList＜int＞与ArrayList＜String＞就是同一个类，
				所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。
			将一段Java代码编译成Class文件，然后再用字节码反编译工具进行反编译后，将会发现泛型都不见了，程序又变回了Java泛型出现之前的写法，泛型类型都变回了原生类型（因为）


			使用泛型注意事项（小甜点，了解即可，装B专用）:{
				上面这段代码是不能被编译的，因为参数List＜Integer＞和List＜String＞编译之后都被擦除了，变成了一样的原生类型List＜E＞，
					擦除动作导致这两种方法的特征签名变得一模一样（注意在IDEA中是不行的，但是jdk的编译器是可以，因为jdk是根据方法返回值+方法名+参数）。

				JVM版本兼容性问题：JDK1.5以前，为了确保泛型的兼容性，JVM除了擦除，其实还是保留了泛型信息
					(Signature是其中最重要的一项属性，它的作用就是存储一个方法在字节码层面的特征签名，这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息)----弱记忆
				另外，从Signature属性的出现我们还可以得出结论，擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，
					这也是我们能通过反射手段取得参数化类型的根本依据。
			}

		}

	}


}

java:class文件和字节码文件，




