
1、虚拟机的前世今生，深入理解JVM内存区域：{

	JVMs是C++、C、go语言写的，
	为什么要了解虚拟机：{
		写出更好、更优雅的Java程序
		排查问题，Java应用性能优化
		面试必问

		千万别说：重启重启，重启之前一定要保存堆栈日志。

	}

	虚拟机的发展：{
		HoptSpot VM(SUN)以前使用范围最广泛的java向虚拟机，
		JRockit VM(BEA) 号称世界上最快的虚拟机，
		HoptSpot VM(ORACLE) 目前世界上范围最广的java虚拟机。
			ORACLE把SUN和BEA都收购了合并成了现如今使用最广泛的JVM，
		jdk11推出了一个ZGC(回收内存要达到TB级别，每次回收要达到10毫秒，系统卡顿不超过10毫秒)：有色指针和加载屏障，
	}

	未来的Java技术：{
		模块化:OSGI（动态化、模块化），应用层面就是微服务，互联网的发展方向
		混合语言：多个语言都可以运行在JVM中，google的Kotlin 成为了 Android 的官方语言。Scala(Kafka)
		多核并行：CPU从高频次转变为多核心，多核时代。JDK1.7引入了Fork/Join，JDK1.8提出lambda表达式(函数式编程天生适合并行运行)
		丰富语法：JDK5提出自动装箱、泛型(并发编程讲到)、动态注解等语法。JDK7二进制原生支持。try-catch-finally 至try-with-resource
		64位：虽然同样的程序64位内存消耗比32位要多一点，但是支持内存大，所以虚拟机都会完全过渡到64位，32位的JVM有4G的堆大小限制。
		更强的垃圾回收器（现在主流CMS、G1）：JDK11 CZGC（暂停时间不超过10毫秒，且不会随着堆的增加而增加，TB级别的堆回收））：有色指针、加载屏障。JDK12支持并发类卸载，进一步缩短暂停时间  JDK13(计划于2019年9月)将最大堆大小从4TB增加到16TB

	}

	Java SE体系架构:{
		JavaSE，Java平台标准版，为Java EE和Java ME提供了基础。
		JDK：Java开发工具包，JDK是JRE的超集，包含JRE中的所有内容，以及开发程序所需的编译器和调试程序等工具。
		JRE：Java SE运行时环境 ，提供库、Java虚拟机和其他组件来运行用Java编程语言编写的程序。主要类库，包括：程序部署发布、用户界面工具类、继承库、其他基础库，语言和工具基础库
		JVM：java虚拟机，负责JavaSE平台的硬件和操作系统无关性、编译执行代码（字节码）和平台安全性

		jre体系中如果没有用到如JDBC，也是能跑通的；但是JVM是最基础的，是不能缺的的。
		java代码经过jdk的javac编译成.class文件(字节码)，再经过JVM把class文件翻译成操作系统的指令(就是常见的011000d)，
	}


	JVM运行时数据区(内存):就是指计算机上的内存，无论什么系统，都是内存，不是指磁盘----{
		这个是抽象概念，内部实现依赖寄存器、高速缓存、主内存（具体要分析JVM源码 C++语言实现，没必要看）
			计算机的运行=指令+数据，指令用于执行方法的，数据用于存放数据和对象的。
			虚拟机栈----执行java方法、本地方法栈---执行本地方法、程序计数器---程序执行的计数器
			Java中的数据：变量、常量、对象、数组相关。

		JVM在运行过程中会把它所管理的内存划分成若干不同的数据区域！
		线程私有:程序计数器、虚拟机栈、本地方法栈
		线程共享：堆、方法区

	}


	程序计数器/程序的计数器(虚拟机内存，唯一不会OOM)：{

		含义：指向当前线程正在执行的字节码指令的地址/行号。

		较小的内存空间，当前线程执行的字节码指令的行号指示器；
			各线程之间独立存储，互不影响（面试可能问到为什么需要）
			如果线程正在执行的是一个Java方法，则指明当前线程执行的代字节码行数
			如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）
			此内存区域是唯一一个不会出现OutOfMemoryError情况的区域。

		为什么需要程序计数器（面试）：{
			java是多线程的，记录线程执行地址方便线程切换；
			确保多线程情况下程序正常执行，
		}


	}

	用栈的结构完成代码的操作，
	虚拟机栈（JVM后续的执行子程序有详细的见解）：{

		栈/Stack：{
			栈是一种数据结构，
				入栈
				出栈
			特点：先进后出(FILO)，

		}
		为什么JVM使用栈？
			非常适合方法调方法，兼容这种特点。

		异常：
			线程请求的栈深度大于虚拟机所允许的深度：StackOverflowError
			JVM动态扩展时无法申请到足够的内存时：OutOfMemoryError


		虚拟机栈（大小设置  -Xss 1M：虚拟机栈如果不设置大小的话，默认1M ）
			存储当前线程运行方法所需的数据---->指令、返回地址

		每个线程私有的，线程在运行时，在执行每个方法的时候都会打包成一个栈帧，存储了局部变量表，操作数栈，动态链接，方法出口等信息，然后放入栈。
			每个时刻正在执行的当前方法就是虚拟机栈顶的栈桢。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。
			栈的大小缺省为1M，可用参数 CXss调整大小，例如-Xss256k
		在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中，
			因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。
		//重点
		栈帧--是对虚拟机栈的进一步划分:
			每个方法在执行的同时都会创建一个栈帧
			栈帧还可以划分：//栈帧不单单只有这四个东西，还有其他东西，只是这四个东西比较重要。
				局部变量表:{
					顾名思义就是局部变量的表，用于存放我们的局部变量的。
						首先它是一个32位的长度，主要存放我们的Java的八大基础数据类型，一般32位就可以存放下，如果是64位的就使用高低位占用两个也可以存放下，
						如果是局部的一些对象，比如我们的Object对象，我们只需要存放它的一个引用地址即可。（基本数据类型、对象引用、returnAddress类型）
				}

				操作数栈--->可以不连续，但是一定要是增序的:{
					存放我们方法执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的java数据类型，
						所以我们知道一个方法刚刚开始的时候，这个方法的操作数栈就是空的，操作数栈运行方法是会一直运行入栈/出栈的操作
				}

				动态连接:Java语言特性多态（需要类加载、运行时才能确定具体的方法，后续有详细的讲解）
				返回地址:正常返回（调用程序计数器中的地址作为返回）

				三步曲：
					恢复上层方法的局部变量表和操作数栈、
					把返回值（如果有的话）压入调用者栈帧的操作数栈中、
					调整PC计数器的值以指向方法调用指令后面的一条指令、
					异常的话（通过异常处理器表<非栈帧中的>来确定）




	}

	本地方法栈:{
		各虚拟机自由实现，本地方法栈native方法调用 JNI到了底层的C/C++(c/c++可以触发汇编语言，然后驱动硬件)

		本地方法栈保存的是native方法的信息，当一个JVM创建的线程调用native方法后，JVM不再为其在虚拟机栈中创建栈帧，JVM只是简单地动态链接并直接调用native方法

	}



	线程私有部分保存的是大多是指令，而公共区域保存的是数据，
	线程共享的区域：{
		类信息：
		类的完整有效名、返回值类型、修饰符(public，private...)、变量名、方法名、方法代码、这个类型直接父类的完整有效名(除非这个类型是interface或是 java.lang.Object，
			两种情况下都没有父类)、类的直接接口的一个有序列表

		方法区还一个叫法：永久代(<=1.7)、元空间(>=1.8)，只是一个版本的区分.
		方法区(永久代、元空间):{
			包括：类信息、常量、静态变量、即时编译期编译后的代码；
			用于存储已经被虚拟机加载的类信息，常量("zdy","123"等)，静态变量(static变量)等数据，可用以下参数调整：
				jdk1.7及以前：-XX:PermSize；-XX:MaxPermSize；
				jdk1.8以后：-XX:MetaspaceSize； -XX:MaxMetaspaceSize
				jdk1.8以后大小就只受本机总内存的限制
				如：-XX:MaxMetaspaceSize=3M

			常量：


			静态变量：

			即时编译期编译后的代码：


		}

		堆:{
			包括对象和成员变量，
			几乎所有对象都分配在这里，也是垃圾回收发生的主要区域，可用以下参数调整：
				-Xms：堆的最小值；
				-Xmx：堆的最大值；
				-Xmn：新生代的大小；
				-XX:NewSize；新生代最小值；
				-XX:MaxNewSize：新生代最大值；
				例如- Xmx256m
		}

		运行时常量池:{
			包括：符号引用和字面量.
			符号引用（一个概念）
				一个java类（假设为People类）被编译成一个class文件时，如果People类引用了Tool类，但是在编译时People类并不知道引用类的实际内存地址，因此只能使用符号引用来代替。
				而在类装载器装载People类时，此时可以通过虚拟机获取Tool类的实际内存地址，因此便可以既将符号org.simple.Tool替换为Tool类的实际内存地址，及直接引用地址。
				即在编译时用符号引用来代替引用类，在加载时再通过虚拟机获取该引用类的实际地址.
				以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
					符号引用与虚拟机实现的内存布局是无关的，引用的目标不一定已经加载到内存中。
			字面量
				文本字符串	String a = "abc",这个abc就是字面量
				八种基本类型int a = 1; 这个1就是字面量
				声明为final的常量

			常量池的变化
				运行时常量池
					Class 文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域。
					符号引用:
					字面量：String a =“享学课堂”
				JDK1.6
					运行时常量池在方法区中
				JDK1.7
					运行时常量池在堆中
				JDK1.8
					去永久代：使用元空间(空间大小只受制于机器的内存)替代永久代
					永久代参数	-XX:PermSize；-XX:MaxPermSize =100M   超过100M OOM（）
					元空间参数	-XX:MetaspaceSize； -XX:MaxMetaspaceSize
				why？
					永久代来存储类信息、常量、静态变量等数据不是个好主意, 很容易遇到内存溢出的问题。
					对永久代进行调优是很困难的,同时将元空间与堆的垃圾回收进行了隔离，避免永久代引发的Full GC和OOM等问题；



		}






	}

	直接内存---JVM直接管理不了的，内存中除运行时数据区剩余的部分:{
		使用Native函数库直接分配堆外内存(NIO)
		并不是JVM运行时数据区域的一部分，但是会被频繁使用(可以通过-XX:MaxDirectMemorySize来设置（默认与堆内存最大值一样,也会出现OOM异常)
		避免了在Java 堆和Native 堆中来回复制数据，能够提高效率
		测试用例JavaStack：设置JVM参数-Xmx100m，运行异常，因为如果没设置-XX:MaxDirectMemorySize，则默认与-Xmx参数值相同，分配128M直接内存超出限制范围.

		直接内存//重要：
			不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域；
			如果使用了NIO,这块区域会被频繁使用，在java堆内可以用directByteBuffer对象直接引用并操作；
			这块内存不受java堆大小限制，但受本机总内存的限制，可以通过MaxDirectMemorySize来设置（默认与堆内存最大值一样），所以也会出现OOM异常；
			避免了在Java 堆和Native 堆中来回复制数据，能够提高效率

	}

	站在线程角度来看:{
		线程私有的内存区：不需要过多考虑内存回收问题，随着线程产生和消亡，生命周期跟随现成的，
		线程共享的内存区：
	}

	深入辨析堆和栈:{
		功能
			以栈帧的方式存储方法调用的过程，并存储方法调用过程中基本数据类型的变量（int、short、long、byte、float、double、boolean、char等）以及对象的引用变量，
				其内存分配在栈上，变量出了作用域就会自动释放；
			而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中；
		线程独享还是共享
			栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。
			堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。
		空间大小
			栈的内存要远远小于堆内存,栈的深度是有限制的，可能发生StackOverFlowError问题。

	}




	反编译::{
		进入到某个文件目录：javap -v .class  >a.text
			-v:显示全一点，将.class文件反编译到a.text;
	}

	Java字节码指令收集大全：
		资料：https://www.cnblogs.com/longjee/p/8675771.html






}



2、情犊初开，JVM搞对象：{

	1.7/及以前:堆的区域以前可以称为永久代，对象分配和垃圾回收和堆一样，
	永久代和元空间的区别：内存分配和垃圾回收策略不同，

	堆：{
		堆：堆是内存分配和垃圾回收的重点区域，几乎所有的对象都是在堆中分配。
		检查加载---->内存分配---->内存初始化---->设置---->对象初始化(new 调用构造方法)
		实例数据：对象是哪个类的实例拥有，

	}


	虚拟机中的对象:{

		对象的分配:{

			虚拟机遇到一条new指令时：根据new的参数是否能在常量池中定位到一个类的符号引用,如果没有，说明还未定义该类，抛出ClassNotFoundException；

			1/检查加载
				先执行相应的类加载过程。如果没有，则进行类加载


			//内存是规整的使用指针碰撞，内存是零散的使用空闲列表。
			2/分配内存::根据方法区的信息确定为该类分配的内存空间大小
				2.1/指针碰撞	(java堆内存空间规整的情况下使用)
					接下来虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。
					如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，
						那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。
				2.2/空闲列表	(java堆空间不规整的情况下使用)
					如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，
						记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。
					选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
				2.3/并发安全
					除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，
						在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。
					2.3.1/CAS机制
						解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理――实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；
					2.3.2/分配缓冲
						另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块私有内存，
							也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），如果设置了虚拟机参数 -XX:+UseTLAB，在线程初始化时，
							同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，
							这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。
						TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间（Eden区，默认Eden的1%），减少同步开销。
						TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。
							当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB。
					//小结
					并发安全问题：
						分配内存什么时候使用CAS配置，什么时候使用本地线层分配缓冲

					本地线层分配缓冲(Thread Local Allocation Buffer,TLAB)：空间换时间，
						对象小的话会在永久代的Eden区分配内存，仅占1%，
						对象大的话，使用CAS比较和交换，确保原子性。

			3/内存空间初始化
				（注意不是构造方法）内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(如int值为0，boolean值为false等等)。
					这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
			4/设置
				接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。
				这些信息存放在对象的对象头之中。
			5/对象初始化
				在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。
					所以，一般来说，执行new指令之后会接着把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

		}

	}


	对象的内存布局:{

		在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。
			1/对象头包括两部分信息，
				第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。
				另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
			2/第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。
				由于HotSpot VM的自动内存管理系统要求对对象的大小必须是8字节的整数倍。
				对象正好是9字节的整数，所以当对象其他数据部分（对象实例数据）没有对齐时，就需要通过对齐填充来补全。

	}


	对象的访问定位:{

		建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针两种。
		句柄
			如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，
				而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
		直接指针
			如果使用直接指针访问， reference中存储的直接就是对象地址。
			这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，
				在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。
			使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，
				因此这类开销积少成多后也是一项非常可观的执行成本。
			对Sun HotSpot而言，它是使用直接指针访问方式进行对象访问的。

		//访问方式
		对象的访问方式：
			使用句柄：
			句柄池：句柄中包含了对象实例数据与类型数据各自的具体地址信息。
			对象实例数据在堆中，
			类型数据在方法区，属于哪个类，和哪个类进行关联的，

			直接指针：HotSpot使用都是直接指针


			实例数据变了直接指针需要修改reference,句柄需要修改句柄池

	}


	堆内存分配策略:{

		新生代：
			Eden区
			Survivor(from)区：设置Survivor是为了减少送到老年代的对象
			Survivor(to)区：设置两个Survivor区是为了解决碎片化的问题（复制回收算法）
			不设置的情况下：Eden:From：To==8:1:1

		java为什么流行：GC的强大，不用担心内存溢出，
		//FullGC 空间不够用了，触发FullGC ，是老年代触发的；FullGC 是老年代进行的，同时伴随着新生代的MinGC
		//当Eden区没有足够空间分配时，虚拟机将发起一次Minor GC。
		minGC频次较高，
		新生代：老年代===1:2
		Full GC会暂停：方便统计对象，但会影响性能，

		对象优先在Eden区分配:{
			虚拟机参数：
				-Xms20m 	//堆最小值，
				-Xmx20m 	//堆最大值:
				-Xmn10m 	//新生代大小参数，-Xmn20M表示新生代大小20M(初始和最大)，
				-XX:+PrintGCDetails //打印垃圾回收日志，程序退出时输出当前内存的分配情况
									//打印垃圾回收日志情况，同时打印堆使用比例，
				注意：新生代初始时就有大小
				大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间分配时，虚拟机将发起一次Minor GC。

		}

		大对象直接进入老年代:{
			-Xms20m
			-Xmx20m
			-Xmn10m
			-XX:+PrintGCDetails
			-XX:PretenureSizeThreshold=4m
			-XX:+UseSerialGC
			PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效。
			最典型的大对象是那种很长的字符串以及数组。这样做的目的：1.避免大量内存复制,2.避免提前进行垃圾回收，明明内存有空间进行分配。
		}

		长期存活对象进入老年区:

			如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1，
				对象在Survivor区中每熬过一次 Minor GC，年龄就增加1，当它的年龄增加到一定程度(默认为15)_时，就会被晋升到老年代中。

		对象年龄动态判定:
			如果在 Survivor空间中相同年龄所有对象大小的综合大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代

		空间分配担保:
			在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。
				如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，
				如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的，如果担保失败则会进行一次Full GC；如果小于，或者HandlePromotionFailure设置不允许冒险，
				那这时也要改为进行一次Full GC。

		空间分配担保：就是JVM把对象直接放入老年代，不用关心老年代是否能放得下，大多数情况下是可以放得下的，放不下在触发GC，
		空间分配担保作用：提高效率，不用每次都触发GC，

	}


	java的语法糖：JVM的泛型，泛型就是语法糖，本质Object,
	泛型有：K,V,T,E<K,V>.
		泛型本质就是形参，实际使用是实参，
		？可以表示所有，T泛型

	Java中的泛型----关注JVM的泛型实现:{

		泛型是什么:{
			泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？
			顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。

			泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，
				这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。
			引入一个类型变量T（其他大写字母都可以，不过常用的就是T，E，K，V等等），并且用<>括起来，并放在类名的后面。泛型类是允许有多个类型变量的。
		}

		泛型类
		泛型接口
		泛型方法

		为什么我们需要泛型？{

			实际开发中，经常有数值类型求和的需求，例如实现int类型的加法,有时候还需要实现long类型的求和,如果还需要double类型的求和，需要重新在重载一个输入是double类型的add方法。
			所以泛型的好处就是：
			?	适用于多种数据类型执行相同的代码
			?	泛型中的类型在使用时指定，不需要强制类型转换



		}


		虚拟机是如何实现泛型的？{
			Java语言中的泛型，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（Raw Type，也称为裸类型）了，
				并且在相应的地方插入了强制转型代码，因此，对于运行期的Java语言来说，ArrayList＜int＞与ArrayList＜String＞就是同一个类，
				所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。
			将一段Java代码编译成Class文件，然后再用字节码反编译工具进行反编译后，将会发现泛型都不见了，程序又变回了Java泛型出现之前的写法，泛型类型都变回了原生类型（因为）


			使用泛型注意事项（小甜点，了解即可，装B专用）:{
				上面这段代码是不能被编译的，因为参数List＜Integer＞和List＜String＞编译之后都被擦除了，变成了一样的原生类型List＜E＞，
					擦除动作导致这两种方法的特征签名变得一模一样（注意在IDEA中是不行的，但是jdk的编译器是可以，因为jdk是根据方法返回值+方法名+参数）。

				JVM版本兼容性问题：JDK1.5以前，为了确保泛型的兼容性，JVM除了擦除，其实还是保留了泛型信息
					(Signature是其中最重要的一项属性，它的作用就是存储一个方法在字节码层面的特征签名，这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息)----弱记忆
				另外，从Signature属性的出现我们还可以得出结论，擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，
					这也是我们能通过反射手段取得参数化类型的根本依据。
			}

		}

	}


}

垃圾回收主要是堆，方法去中回收效率不高，栈的垃圾随线程创建而存在，随线程消亡而消失。
3、垃圾回收算法与垃圾回收器：{


	学习垃圾回收的意义：{

		Java与C++等语言最大的技术区别：自动化的垃圾回收机制（GC），
			为什么要了解GC和内存分配策略
				1/面试需要
				2/GC对应用的性能是有影响的；
				3/写代码有好处
			栈：栈中的生命周期是跟随线程，所以一般不需要关注
			堆：堆中的对象是垃圾回收的重点
			方法区/元空间：这一块也会发生垃圾回收，不过这块的效率比较低，一般不是我们关注的重点

	}


	判断对象的存活:{

		引用计数法:
			给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。（Python在用，但主流虚拟机没有使用）
			优点：快，方便，实现简单。
			缺陷：对象相互引用时（A.instance=B同时B.instance=A），形成死循环，很难判断对象是否该回收。

		可达性分析（Java中使用）：（面试时重要的知识点，牢记）
			来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，
				搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
			作为GC Roots的对象包括下面几种：
				当前虚拟机栈中局部变量表中的引用的对象
				当前本地方法栈中局部变量表中的引用的对象
				方法区中类静态属性引用的对象
				方法区中的常量引用的对象

		请忘记 finalize
			finalize可以完成对象的拯救，但是JVM不保证一定能执行，所以请忘记这个“坑”。
			finalize早期是做对象拯救的，拯救我们的对象不被垃圾回收，但虚拟机不一定确保能调用这个方法finalize(),

	}


	各种引用（Reference）：{
		传统定义：Reference中存储的数据代表的是另一块内存的起始地址。
		强引用
			一般的Object obj = new Object() ，就属于强引用。
			（如果有GCroots的强引用）垃圾回收器绝对不会回收它，当内存不足时宁愿抛出 OOM 错误，使得程序异常停止
		软引用 SoftReference
			垃圾回收器在内存充足的时候不会回收它，而在内存不足时会回收它
			软引用非常适合于创建缓存。当系统内存不足的时候，缓存中的内容是可以被释放的。
			一些有用但是并非必需，用软引用关联的对象，系统将要发生OOM之前，这些对象就会被回收。
		弱引用 WeakReference
			垃圾回收器在扫描到该对象时，无论内存充足与否，都会回收该对象的内存。
			一些有用（程度比软引用更低）但是并非必需，用弱引用关联的对象，只能生存到下一次垃圾回收之前，GC发生时，不管内存够不够，都会被回收。

		虚引用 PhantomReference
			幽灵引用，最弱，被垃圾回收的时候收到一个通知
			如果一个对象只具有虚引用，那么它和没有任何引用一样，任何时候都可能被回收。
			虚引用主要用来跟踪对象被垃圾回收器回收的活动



	}



	GC（Garbage Collection）：{

		Minor GC
			特点: 发生在新生代上，发生的较频繁，执行速度较快
			触发条件: Eden区空间不足\空间分配担保
		Full GC
			特点:主要发生在老年代上（新生代也会回收），较少发生，执行速度较慢
			触发条件:
			调用 System.gc()
			老年代区域空间不足
			空间分配担保失败
			JDK 1.7 及以前的永久代(方法区)空间不足
			CMS GC处理浮动垃圾时，如果新生代空间不足，则采用空间分配担保机制，如果老年代空间不足，则触发Full GC


	}


	垃圾回收算法：{


		From To就是复制算法，划分一半，回收区域越小，性能越高，
		复制算法（Copying）{

			将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，
				然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，
				只要按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半。
			注意：内存移动是必须实打实的移动（复制），不能使用指针玩。

			专门研究表明，新生代中的对象98%是“朝生夕死”的，所以一般来说回收占据10%的空间够用了，所以并不需要按照1:1的比例来划分内存空间，
				而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[1]。
				当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。
			HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。

			优点
				简单高效，不会出现内存碎片问题
			缺点
				内存利用率低，只有一半
				存活对象较多时效率明显会降低

		}


		标记-清除算法（Mark-Sweep）{
			过程:
			1/首先标记所有需要回收的对象
			2/统一回收被标记的对象
			优点
				利用率百分之百

			缺点：
				1/效率问题，标记和清除效率都不高
				2/标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，
				无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

		}


		标记-整理算法（Mark-Compact）{
			首先标记出所有需要回收的对象，在标记完成后，后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
			优点
				利用率百分之百
				没有内存碎片
			缺点
				标记和清除的效率都不高
				效率相对标记-清除要低
		}


	}


	垃圾回收器:{

		分代收集:
			根据各个年代的特点选取不同的垃圾收集算法
				新生代使用复制算法
				老年代使用标记-整理或者标记-清除算法
			在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。
			而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记―清理”或者“标记―整理”算法来进行回收。
			请记住下图的垃圾收集器和之间的连线关系。

			并行：垃圾收集的多线程的同时进行。
			并发：垃圾收集的多线程和应用的多线程同时进行。

			注：吞吐量=运行用户代码时间/(运行用户代码时间+ 垃圾收集时间)
			垃圾收集时间= 垃圾回收频率 * 单次垃圾回收时间


		垃圾回收器相互配合使用，有些不适于配套使用。

		各种垃圾回收器：{

			Serial/Serial Old：
				最古老的，单线程，独占式，成熟，适合单CPU  服务器
				-XX:+UseSerialGC 新生代和老年代都用串行收集器
				-XX:+UseParNewGC 新生代使用ParNew，老年代使用Serial Old
				-XX:+UseParallelGC 新生代使用ParallerGC，老年代使用Serial Old

			ParNew：
				和Serial基本没区别，唯一的区别：多线程，多CPU的，停顿时间比Serial少
				-XX:+UseParNewGC 新生代使用ParNew，老年代使用Serial Old
				除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。

			Parallel Scavenge（ParallerGC）/Parallel Old:
				关注吞吐量的垃圾收集器，高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。
				所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。


			CMS非常关注响应时间，
				对CPU要求比较高，
				浮动垃圾
				采用标记清除算法，产生内存碎片。

			Concurrent Mark Sweep （CMS）：{

				收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，
					这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。
				-XX:+UseConcMarkSweepGC ，一般新生代使用ParNew，老年代的用CMS
				从名字（包含“Mark Sweep”）上就可以看出，CMS收集器是基于“标记―清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，


				垃圾回收过程
					整个过程分为4个步骤，包括：
					?	初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿（STW -Stop the world）。
					?	并发标记：从GC Root 开始对堆中对象进行可达性分析，找到存活对象，它在整个回收过程中耗时最长，不需要停顿。
					?	重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿(STW)。这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。
					?	并发清除：不需要停顿。

				优点：
					由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。

				缺点：
					CPU资源敏感：因为并发阶段多线程占据CPU资源，如果CPU资源不足，效率会明显降低。
					浮动垃圾：由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，
						CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。
						由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。
						在1.6的版本中老年代空间使用率阈值(92%)
						如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。
					会产生空间碎片：标记 - 清除算法会导致产生不连续的空间碎片


			}




			G1垃圾回收器:{

				G1中重要的参数：
					-XX:+UseG1GC   使用G1垃圾回收器
				内部布局改变
					G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。
					算法：标记―整理 （humongous） 和复制回收算法(survivor)。

				GC模式:{
					Young GC
						选定所有年轻代里的Region。通过控制年轻代的region个数，即年轻代内存大小，来控制young GC的时间开销。（复制回收算法）
					Mixed GC
						选定所有年轻代里的Region，外加根据global concurrent marking统计得出收集收益高的若干老年代Region。
							在用户指定的开销目标范围内尽可能选择收益高的老年代Region。
						Mixed GC不是full GC，它只能回收部分老年代的Region。如果mixed GC实在无法跟上程序分配内存的速度，
							导致老年代填满无法继续进行Mixed GC，就会使用serial old GC（full GC）来收集整个GC heap。所以我们可以知道，G1是不提供full GC的。
					全局并发标记（global concurrent marking）{

						初始标记：仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，
							能在正确可以的Region中创建对象，此阶段需要停顿线程(STW)，但耗时很短。

						并发标记：从GC Root 开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行。

						最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，
							最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程(STW)，但是可并行执行。

						筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，
							但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。



					}





				}

				特点：{

					空间整合：不会产生内存碎片
						算法：标记―整理 （humongous） 和复制回收算法(survivor)。
					可预测的停顿：
						G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。
							G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，
							每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。
							这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。
						G1把内存“化整为零”的思路，理解起来似


				}


			}

			垃圾回收器的重要参数（使用-XX:）
















		}


		Stop The World现象
			GC收集器和我们GC调优的目标就是尽可能的减少STW的时间和次数。



	}




}


新生代内存不足会发生MinGC
什么时候会发生GC：虚拟机分配内存不够的时候，
GC主要是堆，方法区也有，

G1低于8G内存最好不要玩，
finalize早期是做对象拯救的，拯救我们的对象不被垃圾回收，但虚拟机不一定确保能调用这个方法finalize(),
4、{
	字节码文件就是.class文件，
	符号引用：类的权限访问路径，


	虚拟机基于栈，物理机基于寄存器，

	什么是类？

	类改动一点就要重编译，java的缺点，
	如何判断一个类是否初始化？
		五种情况类会进行初始化，

	面试题：




	Class文件结构：{
		计算机只认识0和1，这个称之为本地机器NativeCode

		Jvm的无关性
			平台无关性：与平台无关性是建立在操作系统上，虚拟机厂商提供了许多可以运行在各种不同平台的虚拟机，它们都可以载入和执行字节码，
				从而实现程序的“一次编写，到处运行” https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
			语言无关性：各种不同平台的虚拟机与所有平台都统一使用的程序存储格式――字节码（ByteCode）是构成平台无关性的基石，也是语言无关性的基础。
				Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。

		Class类文件（了解即可）
			任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，Class文件实际上它并不一定以磁盘文件的形式存在。
			Class文件是一组以8位字节为基础单位的二进制流。

		Class文件格式
			各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。
			Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表。
			无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。
			表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。

		Class文件格式详解
			Class的结构不像XML等描述语言，由于它没有任何分隔符号，所以在其中的数据项，无论是顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。
			按顺序包括：
				魔数与Class文件的版本：
				常量池：
					常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。
					字面量：：比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。
					符号引用：：则属于编译原理方面的概念，包括了下面三类常量：
						类和接口的全限定名（Fully Qualified Name）、字段的名称和描述符（Descriptor）、方法的名称和描述符


				访问标志：
					用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等
				类索引、父类索引与接口索引集合：
					这三项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。
					由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。
					接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中
				字段表集合：
					描述接口或者类中声明的变量。字段（field）包括类级变量以及实例级变量。
					而字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。
					字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。

				方法表集合：
					描述了方法的定义，但是方法里的Java代码，经过编译器编译成字节码指令后，存放在属性表集合中的方法属性表集合中一个名为“Code”的属性里面。
					与字段表集合相类似的，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。
					但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类构造器“＜clinit＞”方法和实例构造器“＜init＞”

				属性表集合：
					存储Class文件、字段表、方法表都自己的属性表集合，以用于描述某些场景专有的信息。如方法的代码就存储在Code属性表中。


	}

	字节码指令：{
		Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。
		由于限制了Java虚拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不可能超过256条。
		大多数的指令都包含了其操作所对应的数据类型信息。例如：
		iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。
		大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型
		阅读字节码作为了解Java虚拟机的基础技能，有需要的话可以去掌握常见指令。

		简介和重要性
		指令和数据类型
		指令分类
			加载和存储指令
			运算指令
			类型转换指令
			对象创建与访问指令
			操作数栈管理指令
			控制转移指令


	}


	动态链接在方法执行时才知道指向的是谁？编译期间只是一个随便给的地址。
	虚拟机栈再认识：{

		栈帧中的数据在编译后就已经确定了，写在了字节码文件的code属性中（属性表集合）

		栈桢详解
			当前栈帧有效：一个线程的方法调用链可能会很长，这意味着虚拟机栈会被压入很多栈帧，但在线程执行的某个时间点只有位于栈顶的栈帧才是有效的，该栈帧称为“当前栈帧”，与这个栈帧相关联的方法称为“当前方法”。


		每个槽放八大基本数据类型，
		局部变量表
			局部变量表的容量以变量槽（Variable Slot，下称 Slot）为最小单位，虚拟机规范中导向性地说到每个Slot都应该能存放一个boolean、byte、char、short、int、float、double、long8/种数据类型和reference，
				可以使用32位或更小的物理内存来存放。
			对于64位的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。Java 语言中明确的（reference 类型则可能是 32 位也可能是 64 位）64 位的数据类型只有 long 和 double 两种。


		操作数栈
			操作数栈（Operand Stack）也常称为操作栈，它是一个先进后出（FirstIn Last Out,FILO）栈。 同局部变量表一样， 操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。
				32/位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。
			当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。
				例如，在做算术运算的时候是通过操作数栈来进行的，又或者在"调用其他方法的时候是通过操作数栈来进行参数传递的"。
			java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。

		数据重叠优化
			虚拟机概念模型中每二个栈帧都是相互独立的，但在实际应用是我们知道一个方法调用另一个方法时，往往存在参数传递，这种做法在虚拟机实现过程中会做一些优化，
				具体做法如下：令两个栈帧出现一部分重叠。让下面栈帧的一部分操作数栈与上面栈帧的部分局部变量表重叠在一起，进行方法调用时就可以共用一部分数据，无须进行额外的参数复制传递。

		动态连接
			既然是执行方法，那么我们需要知道当前栈帧执行的是哪个方法，栈帧中会持有一个引用（符号引用），该引用指向某个具体方法。
			符号引用是一个地址位置的代号，在编译的时候我们是不知道某个方法在运行的时候是放到哪里的，这时我用代号com/enjoy/pojo/User.Say:()V指代某个类的方法，将来可以把符号引用转换成直接引用进行真实的调用。
			用符号引用转化成直接引用的解析时机，把解析分为两大类
				静态解析：符号引用在类加载阶段或者第一次使用的时候就直接转换成直接引用。
				动态连接：符号引用在每次运行期间转换为直接引用，即每次运行都重新转换。
		方法返回地址
			方法退出方式有：正常退出与异常退出
			理论上，执行完当前栈帧的方法，需要返回到当前方法被调用的位置，所以栈帧需要记录一些信息，用来恢复上层方法的执行状态。
				正常退出，上层方法的PC计数器可以做为当前方法的返回地址，被保存在当前栈帧中。"异常退出时，返回地址是要通过异常处理器表来确定的,栈帧中一般不会保存这部分信息"
			方法退出时会做的操作：恢复上次方法的局部变量表、操作数栈，把当前方法的返回值，压入调用者栈帧的操作数栈中，使用当前栈帧保存的返回地址调整PC计数器的值，当前栈帧出栈，随后，执行PC计数器指向的指令。

		附加信息
			虚拟机规范允许实现虚拟机时增加一些额外信息，例如与调试相关的信息。
			一般把把  动态连接、方法返回地址、其他额外信息归成一类，称为栈帧信息。


	}


	基于栈的字节码解释执行引擎:{
		Java编译器输出的指令流，基本上是一种基于栈的指令集架构，指令流中的指令大部分都是零地址指令，它们依赖操作数栈进行工作。与
		基于寄存器的指令集，最典型的就是x86的二地址指令集，说得通俗一些，就是现在我们主流PC机中直接支持的指令集架构，这些指令依赖寄存器进行工作。

		基于栈的指令集
			举个最简单的例子，分别使用这两种指令集计算“1+1” 的结果，基于栈的指令集会是这样子的：
			iconst_1
			iconst_1
			iadd
			istore_0
			两条iconst_1指令连续把两个常量1压入栈后，iadd指令把栈顶的两个值出栈、相加，然后把结果放回栈顶，最后istore_0把栈顶的值放到局部变量表的第0个Slot中。
		基于寄存器的指令集
			如果基于寄存器，那程序可能会是这个样子：
			mov eax，1
			add eax，1
			mov指令把EAX寄存器的值设为1，然后add指令再把这个值加1，结果就保存在EAX寄存器里面。
			基于栈的指令集主要的优点就是可移植，寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。
				栈架构指令集的主要缺点是执行速度相对来说会稍慢一些。所有主流物理机的指令集都是寄存器架构也从侧面印证了这一点。



	}



	方法调用详解:{
		解析
			调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析。
		静态分派：多见于方法的重载
			“Human”称为变量的静态类型（Static Type），或者叫做的外观类型（Apparent Type），后面的“Man”则称为变量的实际类型（Actual Type），
				静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，
				并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。
			代码中定义了两个静态类型相同但实际类型不同的变量，但虚拟机（准确地说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。
			并且静态类型是编译期可知的，因此，在编译阶段，Javac编译器会根据参数的静态类型决定使用哪个重载版本，所以选择了sayHello（Human）作为调用目标。
			所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是方法重载。
			静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。

		动态分派：多态，
			静态类型同样都是Human的两个变量man和woman在调用sayHello（）方法时执行了不同的行为，并且变量man在两次调用中执行了不同的方法。
				导致这个现象的原因很明显，是这两个变量的实际类型不同。
			在实现上，最常用的手段就是为类在方法区中建立一个虚方法表。虚方法表中存放着各个方法的实际入口地址。
				如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。
				如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。
				PPT图中，Son重写了来自Father的全部方法，因此Son的方法表没有指向Father类型数据的箭头。
				但是Son和Father都没有重写来自Object的方法，所以它们的方法表中所有从Object继承来的方法都指向了Object的数据类型。

	}


	只有直接定义这个静态属性的类才会初始化，

	//如果通过子类引用父类中的静态字段，只会触发父类的初始化，而不会触发子类的初始化
	//常量池\ class编译后，常量池的信息也放入class类中,如果常量池中某个常量字面量被改了，而没有编译，则它仍然指向的是旧的字面量。这也是为什么改动一下文件就要编译一下。
	//如果使用常量去引用另外一个常量,会进行初始化，因为引用常量在编译期间是不可见的，只有在运行期间可见，
	类加载机制：{
		概述
			类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：
				加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。
				其中验证、准备、解析3个部分统称为连接（Linking）

		初始化:类加载的最后一步，
			初始化的5种情况
			初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：
			1/遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。
				生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，
				以及调用一个类的静态方法的时候。
			2/使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
			3/当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
			4/当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类。
			5/当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，
				并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

		加载阶段
			虚拟机需要完成以下3件事情：
			1/通过一个类的全限定名来获取定义此类的二进制字节流。
			2/将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
			3/在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

		验证
			是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
			但从整体上看，验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。

		准备阶段
			是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：
			public static int value=123；
			那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器＜clinit＞（）方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。假设上面类变量value的定义变为：public static final int value=123；
			编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。
		解析阶段
			是虚拟机将常量池内的符号引用替换为直接引用的过程。部分详细内容见解析

		类初始化阶段
			是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。
				到了初始化阶段，才真正开始执行类中定义的Java程序代码在准备阶段，变量已经赋过一次系统要求的初始值，
				而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器＜clinit＞（）方法的过程。
				＜clinit＞（）方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的。
				＜clinit＞（）方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成＜clinit＞（）方法。


	}


	类加载器：{

		对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。
			这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，
			否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。
		这里所指的“相等”，包括代表类的Class对象的equals（）方法、isAssignableFrom（）方法、isInstance（）方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。




	}


	双亲委派模型：{

		对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性.

		从Java虚拟机的角度来讲，只存在两种不同的类加载器：
			一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；
			另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。
		启动类加载器（Bootstrap ClassLoader）：这个类将器负责将存放在＜JAVA_HOME＞\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，
			并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，
			用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。
		扩展类加载器（Extension ClassLoader）：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载＜JAVA_HOME＞\lib\ext目录中的，
			或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
		应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher $App-ClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader（）方法的返回值，
			所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
		我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。
		双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。
		使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，
			它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。
			相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，、
			Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。

		应用程序类加载器：{
			ClassLoader中的loadClass方法中的代码逻辑就是双亲委派模型：
			在自定义ClassLoader的子类时候，我们常见的会有两种做法，一种是重写loadClass方法，另一种是重写findClass方法。
				其实这两种方法本质上差不多，毕竟loadClass也会调用findClass，但是从逻辑上讲我们最好不要直接修改loadClass的内部逻辑。我建议的做法是只在findClass里重写自定义类的加载方法。
			loadClass这个方法是实现双亲委托模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此我们最好是在双亲委托模型框架内进行小范围的改动，不破坏原有的稳定结构。
				同时，也避免了自己重写loadClass方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。

		}

	}


}



