
什么是数据结构：{
	
	数据项：一个数据元素可以有若干个数据项组成；
	数据对象：有相同性质的数据元素的集合，是数据的子集；
	数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。
	
	逻辑结构：是指数据对象中数据元素之间的相互关系。
		包括：集合结构、线性结构、树形结构、图形结构。
	物理结构：是指数据的逻辑结构在计算机中的存储形式。
		包括：顺序存储结构、链式存储结构。
	
}

//C++里的指针就是一个对象
线性表(顺序表和链表)：{

	线性表：零个或多个元素的有限序列。


	顺序表:{

		含义：a1是a2的前驱，ai+1 是ai的后继，a1没有前驱，an没有后继
			  n为线性表的长度 ，若n==0时，线性表为空表

		以ArrayList为例：
			ArrayList类声明：
			public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable{}


		问题：
			ArrayList的大小是如何自动增加的？
			什么情况下你会使用ArrayList？
			在索引中ArrayList的增加或者删除某个对象的运行过程？效率很低吗？解释一下为什么？
			ArrayList如何顺序删除节点
			arrayList的遍历方法

		顺序表的应用：
			优点：尾插尾删效率高，支持随机访问。
			缺点：中间插入或者删除效率低，因为要移动后面的元素。
			应用：ArrayList

		作业：
			https://leetcode.com/problems/remove-duplicates-from-sorted-array/
			https://leetcode.com/problems/search-insert-position/
			https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/


	}


	//链表的查找就是轮训，比较耗时。
	链表:{
		定义：线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。



		单链表：

		双链表：

	}


	List总结:{

		(01)List 是一个接口，它继承于Collection的接口。它代表着有序的队列
		(02) AbstractList 是一个抽象类，它继承于AbstractCollection AbstractList实现List接口中除size()、get(int location)之外的函数。
		(03) AbstractSequentialList 是一个抽象类，它继承于AbstractList.AbstractSequentialList 实现了“链表中，根据index索引值操作链表的全部函数”
		(04) ArrayList, LinkedList, Vector, Stack是List的4个实现类。

	}


	//要点
	双链表知识总结与应用场景：{
					优点												缺点										            	应用
		顺序表：存储空间连续，允许随机访问，尾插，尾删方便；；插入效率低，删除效率低，长度固定；；；；；；；；；；；；；；；；；哪哪都在用？

		单链表：随意增删改，插入删除效率高，长度可以随意修改；；内存不连续，不能随机查找，查找就是轮询；；；；；；；；；；；；；；用的较少

		双链表：随意增删改，插入删除效率高，长度可以随意修改，查找效率比单链表快一倍；；内存不连续，不能随机查找，查找就是轮询；；LinkedList
	}


	//要点
	ArrayList和LinkedList的区别、优缺点：{

		ArrayList：存储空间连续(物理上)，随机访问速度快，尾插尾删较快；；；插入效率低，删除效率低，长度固定；
		LinkedList：存储空间逻辑上是连续的，底层双向链表，增删改快，查找比单链表快一倍，，，查找是轮询，慢；
			1/ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。
			2/对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针，去轮询。
			3/对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。

	}


	作业：
		手写一个单链表，并且实现单链表元素的逆置，（a0, a1,a2,a3,..an）-> (an,an-1,… a1, a0),算法的空间复杂度和时间复杂度经可能低。
		手写双向链表， 实现增删改查，同时对比自己的LinkList 和源码Linkedlist的异同点
		对比源码Arraylist 和LinkedList 的优缺点

		leetcode：
			https://leetcode.com/problems/merge-two-sorted-lists/
			https://leetcode.com/problems/swap-nodes-in-pairs/
			https://leetcode.com/problems/copy-list-with-random-pointer/



}


时间复杂度：O(0)表示最低，
原因是，fastjson反序列化依赖setter，使用lombok插件时，被fianl修饰的不会生成setter方法，static修饰的不会生成getter和setter



队列和栈：{

	队列：插入队列元素的时候，也存在优先级，

	队列常被用于缓存的模式，
		循环队列：
		队列存储结构-链式队列：
			队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已

	队列：{

		什么是队列：
			队列（queue）又叫先进先出表，它是一种运算受限的线性表。
			其限制是仅允许在表的一端进行插入和另一端取数据。
			插入数据的一端是队尾，取数据的一端则是队头。

		循环队列：把队列的这种头尾相连的存储结构被称为循环队列。
			假设循环队列总容量为N，并且预留一个空的位置作为队列空，满，长度判断标志：
			队列空：front==rear;
			队列满：(rear+1)%N==front;
			队列元素个数：（rear C front + N)%N

		队列存储结构-链式队列：
			队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已
			队列的增加和删除元素操作简单


		队列变形――双端队列Deque：
			Deque是一种具有队列和栈的性质的数据结构。双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行

		队列变形――优先级队列
			优先级队列和通常的栈和队列一样，只不过里面的每一个元素都有一个”优先级”，在处理的时候，首先处理优先级最高的。
			如果两个元素具有相同的优先级，则按照他们插入到队列中的先后顺序处理。


		队列编程实战作业
			https://leetcode.com/problems/number-of-recent-calls/

			https://leetcode.com/problems/design-circular-deque/

			https://leetcode.com/problems/task-scheduler/

	}


	什么是栈:{
		栈（stack）又名后进先出表，它是一种运算受限的线性表。
			其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。

		栈基本概念:
			进栈：入栈或压栈，将新元素放到栈顶元素的上面，使之成为新的栈顶元素
			出栈：退栈，将栈顶元素删除掉，使得与其相邻的元素成为新的栈顶元素

		栈的存储结构:
			顺序结构：使用数组实现
			链式结构：使用链表存储结构

		栈基本操作
			进栈：入栈或压栈，将新元素放到栈顶元素的上面，使之成为新的栈顶元素
			出栈：退栈，将栈顶元素删除掉，使得与其相邻的元素成为新的栈顶元素

		栈的面试题
			Java中的Stack是通过Vector来实现的，这种设计被认为是不良的设计，说说你的看法？

			栈的声明：
				public	class Stack<E> extends Vector<E> {}



		栈的经典应用-逆波兰表达式法
			逆波兰表达式是一种利用栈来进行运算的数学表达式

			中缀表达式转为后缀表达式：
			设置一个堆栈，初始时将堆栈顶设置为#
			顺序读入中缀表达式，到读到的单词为数字时将其输出，接着读下一个单词；
			令x1 为栈顶运算符变量，x2 为扫描到的运算符变量，当顺序从表达试中读到的运算符时赋值给x2，然后比较x1 和 x2 的优先级，
				若x1 的优先级高于x2的优先级，将x1退栈并输出，接着比较新的栈顶运算符x1，x2的优先级；若 x1的优先级低于x2的优先级，
				将x2 入栈;如果x1 = “（”且 x2 = “）”，将x1 退栈；若x1的优先级等于x2的优先级且x1 = “#”而x2=“#”时，算法结束


		作业・：栈实现逆波兰表达式？


		JVM虚拟机：{
			JVM：在java编译器和os平台之间的虚拟处理器

			StackOverFlowError
			OutOfMemoryError(OOM)
				他们分别代表什么？1. 一个是栈溢出，另一个是堆溢出(内存溢出)
				他们有什么区别？
				   a.栈解决了程序的运行问题，即程序如何执行，如何处理数据的问题
				   b.堆解决的是数据存储的问题，即数据怎样放，放在哪里
				他们的职责是什么？
					栈负责的是运算逻辑
					堆负责的是存储逻辑


			JVM：递归调用为例：









		}

		作业：
			1:https://leetcode.com/problems/valid-parentheses/
			2:https://leetcode.com/problems/evaluate-reverse-polish-notation/
			3:https://leetcode.com/problems/implement-stack-using-queues/
			4:https://leetcode.com/problems/decode-string/

		吃饱了就是队列，喝高了就是栈

	}



}






































