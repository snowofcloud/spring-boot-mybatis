
映射：{

	两个非空集合A与B间存在着对应关系f，而且对于A中的每一个元素x，B中总有有唯一的一个元素y与它对应，就这种对应为从A到B的映射，记作f：A→B。
		其中，b称为元素a在映射f下的象，记作：b=f(a)。a称为b关于映射f的原象。集合A中所有元素的象的集合称为映射f的值域，记作f(A)。
	或者说，设A,B是两个非空的集合，如果按某一个确定的对应关系f，使对于集合A中的任意一个元素x，在集合B中都有唯一的元素y与之对应，那么就称对应f：A→B为从集合A到集合B的一个映射。
	映射，或者射影，在数学及相关的领域还用于定义函数。函数是从非空数集到非空数集的映射，而且只能是一对一映射或多对一映射。
	映射在不同的领域有很多的名称，它们的本质是相同的。如函数，算子等等。这里要说明，函数是两个数集之间的映射，其他的映射并非函数。一一映射(双射)是映射中特殊的一种，即两集合元素间的唯一对应，通俗来讲就是一个对一个（一对一）。
	注意：(1)对于A中不同的元素，在B中不一定有不同的象；
		  (2)B中每个元素都有原象（即满射），且集合A中不同的元素在集合B中都有不同的象（即单射），则称映射f建立了集合A和集合B之间的一个一一对应关系，也称f是A到B上的一一映射。

}


排序算法：{

	堆排序：{
		堆排序是利用堆这种结构而设计的一种排序算法，是一种选择排序，它的最坏、最好、平均复杂度均为O(nlogn),也是不稳定排序。
		堆是二叉树：每个结点的值都大于等于左右孩子结点的值，称为大顶堆；
					每个结点的值都小于等于左右孩子结点的值，称为小顶堆；
			公式描述一下：
				大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]
				小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]
		堆排序的基本思想及步骤：
			思想：将待排序序列构造成一个大顶堆，此时，整个序列最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就是最大值，
					然后将剩余n-1个元素重新构造成一个堆，这样就会得到n个元素的次小值。如此反复执行，便能得到一个有序序列。
			步骤：
				1/构造初始堆，(升序采用大顶堆，降序采用小顶堆)
				2/将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。
		总结一下排序的基本思路：
			1/将无需序列构成一个堆，根据升序降序选择大顶堆或小顶堆；
			2/将堆顶元素与末尾元素交换，将最大值‘沉’到数组末端；
			3/重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。
			案例应用：{
				public class TimePlayer {
					public static void main(String[] args) {
						int []arr = {9,8,7,6,5,4,3,2,1};
						sort(arr);
						System.out.println(Arrays.toString(arr));
					}

					public static void sort(int []arr){
						//1.构建大顶堆
						for(int i=arr.length/2-1;i>=0;i--){
							//从第一个非叶子结点从下至上，从右至左调整结构
							adjustHeap(arr,i,arr.length);
						}
						//2.调整堆结构+交换堆顶元素与末尾元素
						for(int j=arr.length-1;j>0;j--){
							swap(arr,0,j);//将堆顶元素与末尾元素进行交换
							adjustHeap(arr,0,j);//重新对堆进行调整
						}
					}
					/**
					 * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）
					 * @param arr
					 * @param i
					 * @param length
					 */
					public static void adjustHeap(int []arr,int i,int length){
						int temp = arr[i];//先取出当前元素i
						for(int k=i*2+1;k<length;k=k*2+1){
							//从i结点的左子结点开始，也就是2i+1处开始
							if(k+1<length && arr[k]<arr[k+1]){
								//如果左子结点小于右子结点，k指向右子结点
								k++;
							}
							if(arr[k] >temp){
								//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）
								arr[i] = arr[k];
								i = k;
							}else{
								break;
							}
						}
						arr[i] = temp;//将temp值放到最终的位置
					}
					/**
					 * 交换元素
					 * @param arr
					 * @param a
					 * @param b
					 */
					public static void swap(int []arr,int a ,int b){
						int temp=arr[a];
						arr[a] = arr[b];
						arr[b] = temp;
					}
				}

			}

		最后：
			堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。
			其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)...1]逐步递减，
				近似为nlogn。所以堆排序时间复杂度一般认为就是O(nlogn)级。


	}

	冒泡排序：{
		原理：
			1/比较相邻的元素，如果第一个比第二个大，就交换他们两个；
			2/对每一组相邻元素做同样的工作，从开始第一对到结尾最后一对，在这一点，最后的元素应该会是最大的数；
			3/针对所有的元素重复以上的步骤，除了最后一个；
			4/持续每次对越来越少的元素重复上面的步骤，知道没有任何一对数字需要比较。
		手写冒泡算法案例：{
			public class Test {
				public static void main(String[] args) {
					///冒泡函数代码实现
					int[] arr = {9,40,6,7,1,3,8};

					for (int i = 0; i < arr.length; i++) {
						if ( i <= arr.length-1) {
							sort(arr);
						}

					}

					for ( int i = 0; i < arr.length; i++) {
						System.out.println(arr[i]);
					}


				}

				private static void sort(int[] arr){
					for (int i = 0; i < arr.length-1; i++){
						int temp;
						if (arr[i] >= arr[i+1] ){
							temp = arr[i+1];
							arr[i+1] = arr[i];
							arr[i] = temp;

						} else {
							arr[i] = arr[i];
							arr[i+1] = arr[i+1];
						}
					}
				}

			}
		}

	}

	插入排序：{
		原理：
			1/从第一个元素开始，该元素可以认为已经被排序
			2/取出下一个元素，在已经排序的元素序列中从后向前扫描
			3/如果该元素（已排序）大于新元素，将该元素移到下一位置
			4/重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
			5/将新元素插入到下一位置中
			6/重复步骤2~5


	}

	选择排序：{
		原理：
			对比数组中前一个元素跟后一个元素的大小，如果后面的元素比前面的元素小则用一个变量k来记住他的位置，接着第二次比较，前面“后一个元素”现变成了“前一个元素”，
				继续跟他的“后一个元素”进行比较如果后面的元素比他要小则用变量k记住它在数组中的位置(下标)，等到循环结束的时候，我们应该找到了最小的那个数的下标了，
				然后进行判断，如果这个元素的下标不是第一个元素的下标，就让第一个元素跟他交换一下值，这样就找到整个数组中最小的数了。然后找到数组中第二小的数，
				让他跟数组中第二个元素交换一下值，以此类推
			时间复杂度：O(n^2) ，不稳定
				选择排序的交换操作介于 0 和 (n - 1） 次之间。选择排序的比较操作为 n (n - 1） / 2 次之间。选择排序的赋值操作介于 0 和 3 (n - 1） 次之间。 比较次数O(n^2），
					比较次数与关键字的初始状态无关，总的比较次数N=(n-1）+(n-2）+...+1=n*(n-1）/2。交换次数O(n），最好情况是，已经有序，交换0次；
					最坏情况交换n-1次，逆序交换n/2次。交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。

	}

	堆排序：{
		堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。
		原理：
			1/将无序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;
			2/将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;
			3/重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。


	}

	归并排序：{
		原理：
			将无序的序列分成子序列，将子序列排序在合成有序的序列。
			例如：初始状态：6,202,100,301,38,8,1
				第一次归并后：{6,202},{100,301},{8,38},{1}
				第二次归并后：{6,100,202,301}，{1,8,38}
				第三次归并后：{1,6,8,38,100,202,301}
	}

	快速排序：{
		原理：
			已知数组：A[n]
				设置两个变量i、j，排序开始的时候：i = 0，j = N-1
				以第一个数组元素作为关键数据，赋值给key，即key = A[0]
				从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]的值赋给A[i]
				从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]的值赋给A[j] 5.重复第3、4步，直到i = j


	}

	计数排序：{
		原理：
			首先要排序的数都是整数
				找出最大值max和最小值min
				创建一个大小为max-min+1的数组Temp，每个元素的值都为0
				遍历数，找到Temp对应的下标的元素加1，即统计数出现的次数
				通过遍历Temp，根据统计的每个数的次数，相对应的排序
		计数排序是一种非比较类型的算法，所以没有O(nlogn)的下限，是通过牺牲空间换时间的算法。

	}

	桶排序：{
		原理：
			1/找出最大值max和最小值min
			2/给定一个桶的数量，创建一个桶数组（二维数组），每个桶的范围为（max-min+1）/桶的数量
			3/遍历数，把数值添加到对应范围的桶中，如果桶中有其他数值，按要求排序
			4/通过遍历桶数组，得到一个顺序的数组


	}

}

背包算法：{

}



hash算法：{
	(一)什么是一致性hash，它和普通hash有什么不同(hash环，虚拟节点是干什么的？){
		一致性hash是一种环状hash的数据结构，从0到2的32次方-1/形成一个起点与终点联结的hash环，分别将key对象、缓存节点经过hash处理后，映射到hash环上，
			最后以逆时针就近原则创建key对象与缓存节点之间的映射关系。
		一致性hash和普通hash的不同在于：
			1/一致性hash的缓存在发生增加或删除节点时，不会产生较大的命中率降低问题，但由于采用hash环存数的方式的特性(key对象的hash值的分布是不均匀的，
				可能会有一部分缓存节点会被多数key对象映射上，而部分节点只有少数的key对象映射上)，所以各节点之间存在严重的数据倾斜情况(不采用虚拟节点的情况下)。
				故而可以采用增加虚拟节点的做法来平衡不同节点之间的数据倾斜情况。
			2/普通hash采用余数算法，对key取hash值，然后按缓存节点数取余数，最后根据余数去找服务器列表的数组下标决定存储到哪个节点上，所以各节点的数据分布是比较均匀的，
				并且服务器节点数量的多数对最终数据分布有很大的影响，所以当增加/较少节点时，会打乱已有的缓存分布，造成缓存重组，缓存命中率大大下降。
	}
	(二)一致性hash在什么情况下使用，单节点下使用一致性hash是否合适？
		由于服务器的增减对普通hash影响很大，对一致性hash影响很小，所以在多服务器节点的情况下使用一致性hash，在单节点情况下使用普通hash;



}

slab内存模型是什么样的，对于增长因子来说，它对性能有什么影响？{
	首先内存会被分成多个包含不同chunk大小的SlabClass，每个SlabClass下存在多个默认分配1M的Slab，这些Slab按照特定大小被切分成多个大小相等的chunk。
	每个SlabClass管理的chunk大小是以一个增长因子来固定增长的，比如增长因子设为1.25/，最小设定88bytes的chunk大小，再大一点就时112bytes，接着就是144bytes,
		不同的chunk负责最接近这个内存大小数据存储。

}

