
1、虚拟机的前世今生，深入理解JVM内存区域：{

	JVMs是C++、C、go语言写的，
	为什么要了解虚拟机：{
		写出更好、更优雅的Java程序
		排查问题，Java应用性能优化
		面试必问

		千万别说：重启重启，重启之前一定要保存堆栈日志。

	}

	虚拟机的发展：{
		HoptSpot VM(SUN)以前使用范围最广泛的java向虚拟机，
		JRockit VM(BEA) 号称世界上最快的虚拟机，
		HoptSpot VM(ORACLE) 目前世界上范围最广的java虚拟机。
			ORACLE把SUN和BEA都收购了合并成了现如今使用最广泛的JVM，
		jdk11推出了一个ZGC(回收内存要达到TB级别，每次回收要达到10毫秒，系统卡顿不超过10毫秒)：有色指针和加载屏障，
	}

	未来的Java技术：{
		模块化:OSGI（动态化、模块化），应用层面就是微服务，互联网的发展方向
		混合语言：多个语言都可以运行在JVM中，google的Kotlin 成为了 Android 的官方语言。Scala(Kafka)
		多核并行：CPU从高频次转变为多核心，多核时代。JDK1.7引入了Fork/Join，JDK1.8提出lambda表达式(函数式编程天生适合并行运行)
		丰富语法：JDK5提出自动装箱、泛型(并发编程讲到)、动态注解等语法。JDK7二进制原生支持。try-catch-finally 至try-with-resource
		64位：虽然同样的程序64位内存消耗比32位要多一点，但是支持内存大，所以虚拟机都会完全过渡到64位，32位的JVM有4G的堆大小限制。
		更强的垃圾回收器（现在主流CMS、G1）：JDK11 CZGC（暂停时间不超过10毫秒，且不会随着堆的增加而增加，TB级别的堆回收））：有色指针、加载屏障。JDK12支持并发类卸载，进一步缩短暂停时间  JDK13(计划于2019年9月)将最大堆大小从4TB增加到16TB

	}

	Java SE体系架构:{
		JavaSE，Java平台标准版，为Java EE和Java ME提供了基础。
		JDK：Java开发工具包，JDK是JRE的超集，包含JRE中的所有内容，以及开发程序所需的编译器和调试程序等工具。
		JRE：Java SE运行时环境 ，提供库、Java虚拟机和其他组件来运行用Java编程语言编写的程序。主要类库，包括：程序部署发布、用户界面工具类、继承库、其他基础库，语言和工具基础库
		JVM：java虚拟机，负责JavaSE平台的硬件和操作系统无关性、编译执行代码（字节码）和平台安全性

		jre体系中如果没有用到如JDBC，也是能跑通的；但是JVM是最基础的，是不能缺的的。
		java代码经过jdk的javac编译成.class文件(字节码)，再经过JVM把class文件翻译成操作系统的指令(就是常见的011000d)，
	}


	JVM运行时数据区(内存):就是指计算机上的内存，无论什么系统，都是内存，不是指磁盘----{
		这个是抽象概念，内部实现依赖寄存器、高速缓存、主内存（具体要分析JVM源码 C++语言实现，没必要看）
			计算机的运行=指令+数据，指令用于执行方法的，数据用于存放数据和对象的。
			虚拟机栈----执行java方法、本地方法栈---执行本地方法、程序计数器---程序执行的计数器
			Java中的数据：变量、常量、对象、数组相关。

		JVM在运行过程中会把它所管理的内存划分成若干不同的数据区域！
		线程私有:程序计数器、虚拟机栈、本地方法栈
		线程共享：堆、方法区

	}


	程序计数器/程序的计数器(虚拟机内存，唯一不会OOM)：{

		含义：指向当前线程正在执行的字节码指令的地址/行号。

		较小的内存空间，当前线程执行的字节码指令的行号指示器；
			各线程之间独立存储，互不影响（面试可能问到为什么需要）
			如果线程正在执行的是一个Java方法，则指明当前线程执行的代字节码行数
			如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）
			此内存区域是唯一一个不会出现OutOfMemoryError情况的区域。

		为什么需要程序计数器（面试）：{
			java是多线程的，记录线程执行地址方便线程切换；
			确保多线程情况下程序正常执行，
		}


	}

	用栈的结构完成代码的操作，
	虚拟机栈（JVM后续的执行子程序有详细的见解）：{

		栈/Stack：{
			栈是一种数据结构，
				入栈
				出栈
			特点：先进后出(FILO)，

		}
		为什么JVM使用栈？
			非常适合方法调方法，兼容这种特点。

		异常：
			线程请求的栈深度大于虚拟机所允许的深度：StackOverflowError
			JVM动态扩展时无法申请到足够的内存时：OutOfMemoryError


		虚拟机栈（大小设置  -Xss 1M：虚拟机栈如果不设置大小的话，默认1M ）
			存储当前线程运行方法所需的数据---->指令、返回地址

		每个线程私有的，线程在运行时，在执行每个方法的时候都会打包成一个栈帧，存储了局部变量表，操作数栈，动态链接，方法出口等信息，然后放入栈。
			每个时刻正在执行的当前方法就是虚拟机栈顶的栈桢。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程。
			栈的大小缺省为1M，可用参数 CXss调整大小，例如-Xss256k
		在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中，
			因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。
		//重点
		栈帧--是对虚拟机栈的进一步划分:
			每个方法在执行的同时都会创建一个栈帧
			栈帧还可以划分：//栈帧不单单只有这四个东西，还有其他东西，只是这四个东西比较重要。
				局部变量表:{
					顾名思义就是局部变量的表，用于存放我们的局部变量的。
						首先它是一个32位的长度，主要存放我们的Java的八大基础数据类型，一般32位就可以存放下，如果是64位的就使用高低位占用两个也可以存放下，
						如果是局部的一些对象，比如我们的Object对象，我们只需要存放它的一个引用地址即可。（基本数据类型、对象引用、returnAddress类型）
				}

				操作数栈--->可以不连续，但是一定要是增序的:{
					存放我们方法执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的java数据类型，
						所以我们知道一个方法刚刚开始的时候，这个方法的操作数栈就是空的，操作数栈运行方法是会一直运行入栈/出栈的操作
				}

				动态连接:Java语言特性多态（需要类加载、运行时才能确定具体的方法，后续有详细的讲解）
				返回地址:正常返回（调用程序计数器中的地址作为返回）

				三步曲：
					恢复上层方法的局部变量表和操作数栈、
					把返回值（如果有的话）压入调用者栈帧的操作数栈中、
					调整PC计数器的值以指向方法调用指令后面的一条指令、
					异常的话（通过异常处理器表<非栈帧中的>来确定）




	}

	本地方法栈:{
		各虚拟机自由实现，本地方法栈native方法调用 JNI到了底层的C/C++(c/c++可以触发汇编语言，然后驱动硬件)

		本地方法栈保存的是native方法的信息，当一个JVM创建的线程调用native方法后，JVM不再为其在虚拟机栈中创建栈帧，JVM只是简单地动态链接并直接调用native方法

	}



	线程私有部分保存的是大多是指令，而公共区域保存的是数据，
	线程共享的区域：{
		类信息：
		类的完整有效名、返回值类型、修饰符(public，private...)、变量名、方法名、方法代码、这个类型直接父类的完整有效名(除非这个类型是interface或是 java.lang.Object，
			两种情况下都没有父类)、类的直接接口的一个有序列表

		方法区还一个叫法：永久代(<=1.7)、元空间(>=1.8)，只是一个版本的区分.
		方法区(永久代、元空间):{
			包括：类信息、常量、静态变量、即时编译期编译后的代码；
			用于存储已经被虚拟机加载的类信息，常量("zdy","123"等)，静态变量(static变量)等数据，可用以下参数调整：
				jdk1.7及以前：-XX:PermSize；-XX:MaxPermSize；
				jdk1.8以后：-XX:MetaspaceSize； -XX:MaxMetaspaceSize
				jdk1.8以后大小就只受本机总内存的限制
				如：-XX:MaxMetaspaceSize=3M

			常量：


			静态变量：

			即时编译期编译后的代码：


		}

		堆:{
			包括对象和成员变量，
			几乎所有对象都分配在这里，也是垃圾回收发生的主要区域，可用以下参数调整：
				-Xms：堆的最小值；
				-Xmx：堆的最大值；
				-Xmn：新生代的大小；
				-XX:NewSize；新生代最小值；
				-XX:MaxNewSize：新生代最大值；
				例如- Xmx256m
		}

		运行时常量池:{
			包括：符号引用和字面量.
			符号引用（一个概念）
				一个java类（假设为People类）被编译成一个class文件时，如果People类引用了Tool类，但是在编译时People类并不知道引用类的实际内存地址，因此只能使用符号引用来代替。
				而在类装载器装载People类时，此时可以通过虚拟机获取Tool类的实际内存地址，因此便可以既将符号org.simple.Tool替换为Tool类的实际内存地址，及直接引用地址。
				即在编译时用符号引用来代替引用类，在加载时再通过虚拟机获取该引用类的实际地址.
				以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
					符号引用与虚拟机实现的内存布局是无关的，引用的目标不一定已经加载到内存中。
			字面量
				文本字符串	String a = "abc",这个abc就是字面量
				八种基本类型int a = 1; 这个1就是字面量
				声明为final的常量

			常量池的变化
				运行时常量池
					Class 文件中的常量池（编译器生成的各种字面量和符号引用）会在类加载后被放入这个区域。
					符号引用:
					字面量：String a =“享学课堂”
				JDK1.6
					运行时常量池在方法区中
				JDK1.7
					运行时常量池在堆中
				JDK1.8
					去永久代：使用元空间(空间大小只受制于机器的内存)替代永久代
					永久代参数	-XX:PermSize；-XX:MaxPermSize =100M   超过100M OOM（）
					元空间参数	-XX:MetaspaceSize； -XX:MaxMetaspaceSize
				why？
					永久代来存储类信息、常量、静态变量等数据不是个好主意, 很容易遇到内存溢出的问题。
					对永久代进行调优是很困难的,同时将元空间与堆的垃圾回收进行了隔离，避免永久代引发的Full GC和OOM等问题；



		}






	}

	直接内存---JVM直接管理不了的，内存中除运行时数据区剩余的部分:{
		使用Native函数库直接分配堆外内存(NIO)
		并不是JVM运行时数据区域的一部分，但是会被频繁使用(可以通过-XX:MaxDirectMemorySize来设置（默认与堆内存最大值一样,也会出现OOM异常)
		避免了在Java 堆和Native 堆中来回复制数据，能够提高效率
		测试用例JavaStack：设置JVM参数-Xmx100m，运行异常，因为如果没设置-XX:MaxDirectMemorySize，则默认与-Xmx参数值相同，分配128M直接内存超出限制范围.

		直接内存//重要：
			不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域；
			如果使用了NIO,这块区域会被频繁使用，在java堆内可以用directByteBuffer对象直接引用并操作；
			这块内存不受java堆大小限制，但受本机总内存的限制，可以通过MaxDirectMemorySize来设置（默认与堆内存最大值一样），所以也会出现OOM异常；
			避免了在Java 堆和Native 堆中来回复制数据，能够提高效率

	}

	站在线程角度来看:{
		线程私有的内存区：不需要过多考虑内存回收问题，随着线程产生和消亡，生命周期跟随现成的，
		线程共享的内存区：
	}

	深入辨析堆和栈:{
		功能
			以栈帧的方式存储方法调用的过程，并存储方法调用过程中基本数据类型的变量（int、short、long、byte、float、double、boolean、char等）以及对象的引用变量，
				其内存分配在栈上，变量出了作用域就会自动释放；
			而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中；
		线程独享还是共享
			栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。
			堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。
		空间大小
			栈的内存要远远小于堆内存,栈的深度是有限制的，可能发生StackOverFlowError问题。

	}




	反编译::{
		进入到某个文件目录：javap -v .class  >a.text
			-v:显示全一点，将.class文件反编译到a.text;
	}

	Java字节码指令收集大全：
		资料：https://www.cnblogs.com/longjee/p/8675771.html






}



